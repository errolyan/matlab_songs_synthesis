function test_ok = ExecuteCopySynthesisRegressionTest(n_test, command)
%% Regression test for Yet another vocoder "SPLINS" (Tentative name)
% This test compares generated wave files with the reference files
% generated by the reference implementation
% This function is assumed to run the root of a Citc client
%
% test_ok = ExecuteCopySynthesisRegressionTest;
%
% test_ok = ExecuteCopySynthesisRegressionTest(n_test);
%
% test_ok = ExecuteCopySynthesisRegressionTest(n_test, command); % for debug.
%                                                  % Do not use

% Copyright 2016 Google Inc. All Rights Reserved
% Author: hidekik@google.com (Hideki Kawahara)

% Creation date: 25/May/2016

narginchk(0, 2);
test_ok = false;
if nargin == 0
  command = 'quick_test';
  n_test = 10;
elseif nargin == 1
  command = 'test';
end;
base_directory = 'third_party/vctk_corpus/wav48/';
test_function_location = which('ExecuteCopySynthesisRegressionTest');
base_path_reference = [test_function_location(1:end - 36) 'testdata/'];

if ~isOctave
  sprev = rng('shuffle');
  disp(sprev);
end;

switch command
  case 'initialize' % This command should not be used
    disp('Do not proceed. Exit now!');
    keyboard
    dir_data = dir([base_directory 'p*']);
    n_speakers = length(dir_data);
    test_list = struct;
    for ii = 1:n_speakers
      path_name = [base_directory dir_data(ii).name];
      file_list = dir([path_name '/*.wav']);
      n_files = length(file_list);
      file_name = file_list(randi(n_files)).name;
      test_list(ii).fullpath = [path_name '/' file_name];
      test_list(ii).file_name = file_name;
    end;

    %% initialize test condition

    if ~isOctave
      random_seed = 12345;
      rng(random_seed); % initialize random number generator
      eval('!rm testdata/*.wav');
    else
      oct_command1 = 'rand("seed", 1234)'; % for octave
      oct_command2 = 'randn("seed", 1234)'; % for octave
      eval(oct_command1);
      eval(oct_command2);
      system('rm testdata/*.wav');
    end;

    %% analysis test

    analysis_condition = GenerateOptionForSourceAnalysisNV;
    reference_wav_list = struct;
    for ii = 1:n_test
      if ~isOctave
        random_seed = 12345;
        rng(random_seed); % initialize random number generator
      else
        oct_command1 = 'rand("seed", 1234)'; % for octave
        oct_command2 = 'randn("seed", 1234)'; % for octave
        eval(oct_command1);
        eval(oct_command2);
      end;
      [x, fs] = AudioRead(test_list(ii).fullpath);
      disp([test_list(ii).file_name ' at:' datestr(now)]);
      source_information = AnalyzeSpeechSource(x, fs, analysis_condition);
      reference_wav_list(ii).name = ['syn_ref_' test_list(ii).file_name];
      spectrum_information = ...
        AnalyzeSpeechSpectra(x, fs, source_information.f0, ...
                                     source_information.frame_time);
      %synthsis_out = ...
      y = SynthesizeSpeech(spectrum_information, source_information);
      %y = synthsis_out.synthesized_signal;
      y = y/max(abs(y)) * 0.9;
      AudioWrite([base_path_reference reference_wav_list(ii).name], y, fs);
    end;
    disp('generation completed');

  case {'test', 'quick_test'}
    % Generate unique working directory name
    % This directory has to be deleted afterwards
    tmp_directory_name = ['/tmp/reg_test_' char(randi(25,1,10) + 97) datestr(now, 30) '/'];
    mkdir(tmp_directory_name);
    dir_data_reference = ...
      dir([base_path_reference '*.wav']);
    n_files = length(dir_data_reference);
    [~, sorted_index] = sort(rand(n_files, 1));
    test_index_list = sorted_index(1:n_test);
    reference_wav_list = struct;
    %--- analysis for test
    analysis_condition = GenerateOptionForSourceAnalysisNV;
    test_wav_list = struct;
    for ii = 1:n_test
      if ~isOctave
        random_seed = 12345;
        rng(random_seed); % initialize random number generator
      else
        oct_command1 = 'rand("seed", 1234)'; % for octave
        oct_command2 = 'randn("seed", 1234)'; % for octave
        eval(oct_command1);
        eval(oct_command2);
      end;
      file_name = dir_data_reference(test_index_list(ii)).name;
      reference_wav_list(ii).name = file_name;
      audio_fullpath = [base_directory file_name(9:12) '/' file_name(9:end)];
      [x, fs] = AudioRead(audio_fullpath);
      disp([file_name ' at:' datestr(now)]);
      source_information = ...
        AnalyzeSpeechSource(x, fs, analysis_condition);
      test_wav_list(ii).name = ['syn_test_' file_name(9:end)];
      spectrum_information = ...
        AnalyzeSpeechSpectra(x, fs, source_information.f0, ...
                                     source_information.frame_time);
      y = SynthesizeSpeech(spectrum_information, source_information);
      y = y/max(abs(y)) * 0.9;
      AudioWrite([tmp_directory_name test_wav_list(ii).name], y, fs);
    end;
    disp('second generation completed');
    %--- comparizon of reproducibility
    acceptable_relative_error = 1e-5;
    accepbable_segmental_snr_error = 1e-2;
    tentative_validation_result = true;
    for ii = 1:n_test
      filename1 = [tmp_directory_name test_wav_list(ii).name];
      filename2 = ...
        [base_path_reference reference_wav_list(ii).name];
      if ~ValidateMaxRelativeDifference(filename1, filename2, ...
                                        acceptable_relative_error)
        disp([test_wav_list(ii).name ' failed relative error validation']);
        tentative_validation_result = false;
      end;
      if ~ValidateMaxSegmentalSnrDifference(filename1, filename2,  ...
                                            accepbable_segmental_snr_error)
        disp([test_wav_list(ii).name ' failed segmental SNR error validation']);
        tentative_validation_result = false;
      end;
    end;
    test_ok = tentative_validation_result;
end;
if test_ok
  disp(['Analysis and synthesis validation test passed with ' ...
  num2str(n_test) ' files.']);
end;
end

